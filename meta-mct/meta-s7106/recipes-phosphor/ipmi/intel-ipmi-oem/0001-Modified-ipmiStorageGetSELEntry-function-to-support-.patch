From d60cfaf42817ef3ab496be443d871e95692611b6 Mon Sep 17 00:00:00 2001
From: jeannie <jeannie@localhost.localdomain>
Date: Fri, 3 May 2019 11:24:27 +0800
Subject: [PATCH] Modified ipmiStorageGetSELEntry function to support custom
 parameter

---
 include/storagecommands.hpp |  2 ++
 src/storagecommands.cpp     | 86 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 88 insertions(+)
 mode change 100644 => 100755 include/storagecommands.hpp

diff --git a/include/storagecommands.hpp b/include/storagecommands.hpp
old mode 100644
new mode 100755
index 946161b..ad27614
--- a/include/storagecommands.hpp
+++ b/include/storagecommands.hpp
@@ -27,6 +27,8 @@ namespace intel_oem::ipmi::sel
 static constexpr const char* selMessageId = "b370836ccf2f4850ac5bee185b77893a";
 static constexpr uint8_t selOperationSupport = 0x02;
 static constexpr uint8_t systemEvent = 0x02;
+//Jeannie add for event recoredTypee
+static constexpr uint8_t EventOnlyEvent = 0x03;
 static constexpr size_t systemEventSize = 3;
 static constexpr uint8_t oemTsEventFirst = 0xC0;
 static constexpr uint8_t oemTsEventLast = 0xDF;
diff --git a/src/storagecommands.cpp b/src/storagecommands.cpp
index 620638b..7baf871 100755
--- a/src/storagecommands.cpp
+++ b/src/storagecommands.cpp
@@ -869,6 +869,92 @@ ipmi_ret_t ipmiStorageGetSELEntry(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
                 record.record.system.eventData[1] = evtData[1];
                 record.record.system.eventData[2] = evtData[2];
             }
+	    //Jeannie add for custom event
+	    else if (record.recordType == intel_oem::ipmi::sel::EventOnlyEvent)
+	    {
+		// Get the timestamp
+                uint64_t ts = 0;
+                if (sd_journal_get_realtime_usec(journal.get(), &ts) < 0)
+                {
+                    return IPMI_CC_UNSPECIFIED_ERROR;
+                }
+                record.record.system.timestamp = static_cast<uint32_t>(
+                    ts / 1000 / 1000); // Convert from us to s
+
+                int generatorID = 0;
+                // Get the generator ID from the IPMI_SEL_GENERATOR_ID field
+                if (getJournalMetadata(journal.get(), "IPMI_SEL_GENERATOR_ID",
+                                       16, generatorID) < 0)
+                {
+                    return IPMI_CC_UNSPECIFIED_ERROR;
+                }
+                record.record.system.generatorID = generatorID;
+
+                // Set the event message revision
+                record.record.system.eventMsgRevision =
+                    intel_oem::ipmi::sel::eventMsgRev;
+
+                std::string path;
+                // Get the IPMI_SEL_SENSOR_PATH field
+                if (getJournalMetadata(journal.get(), "IPMI_SEL_SENSOR_PATH",
+                                       path) < 0)
+                {
+                    return IPMI_CC_UNSPECIFIED_ERROR;
+                }
+
+                // Jeannie add for catch event type & sensor type by custom sensor
+                int sensorType=0;
+                if (getJournalMetadata(journal.get(), "IPMI_SEL_SENSOR_TYPE",16,
+                                       sensorType) < 0)
+                {
+                    record.record.system.sensorType = getSensorTypeFromPath(path);
+                }else{
+                    record.record.system.sensorType = sensorType;
+                }
+				
+				int sensorNumber=0;
+                if (getJournalMetadata(journal.get(), "IPMI_SEL_SENSOR_NUMBER",16,
+                                       sensorNumber) < 0)
+                {
+                    record.record.system.sensorNum = getSensorNumberFromPath(path);
+                }else{
+                    record.record.system.sensorNum = sensorNumber;
+				}
+
+                // Jeannie add for catch event type  by custom sensor
+                int eventType=0;
+                if (getJournalMetadata(journal.get(), "IPMI_SEL_EVENT_TYPE",16,
+                                       eventType) < 0)
+                {
+	                record.record.system.eventType =
+        	            getSensorEventTypeFromPath(path);
+                }else{
+                    record.record.system.eventType = eventType;
+                }
+                int eventDir = 0;
+                // Get the event direction from the IPMI_SEL_EVENT_DIR field
+                if (getJournalMetadata(journal.get(), "IPMI_SEL_EVENT_DIR", 16,
+                                       eventDir) < 0)
+                {
+                    return IPMI_CC_UNSPECIFIED_ERROR;
+                }
+                // Set the event direction
+                if (eventDir == 0)
+                {
+                    record.record.system.eventDir = deassertionEvent;
+                }
+
+                std::vector<uint8_t> evtData;
+                // Get the event data from the IPMI_SEL_DATA field
+                if (getJournalSelData(journal.get(), evtData) < 0)
+                {
+                    return IPMI_CC_UNSPECIFIED_ERROR;
+                }
+                record.record.system.eventData[0] = evtData[0];
+                record.record.system.eventData[1] = evtData[1];
+                record.record.system.eventData[2] = evtData[2];
+				
+			}
             else if (record.recordType >=
                          intel_oem::ipmi::sel::oemTsEventFirst &&
                      record.recordType <= intel_oem::ipmi::sel::oemTsEventLast)
